<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Submarine Instruments</title>
    <!--
    ╔════════════════════════════════════════════════════════════════════════════╗
    ║  LAYOUT EDITOR - SECRET KEY COMBINATION                                     ║
    ║                                                                             ║
    ║  Press Ctrl+Shift+E (Windows/Linux) or Cmd+Shift+E (Mac) to toggle          ║
    ║  the visual layout editor. This lets you:                                   ║
    ║    - Drag instruments to reposition them                                    ║
    ║    - Scale instruments using a slider                                       ║
    ║    - Save layout as instruments.css                                         ║
    ║                                                                             ║
    ║  After saving, move the downloaded CSS file to this folder and refresh.     ║
    ╚════════════════════════════════════════════════════════════════════════════╝
    -->
    <!-- Load saved layout CSS (may not exist yet - that's OK) -->
    <link rel="stylesheet" href="instruments/instruments.css" />
  </head>
  <body>
    <!-- Layout Editor Control Panel (hidden by default) -->
    <div id="layout-editor-panel">
      <div class="editor-controls">
        <span><b>Layout Editor</b>: Make this window the right size, go full screen, then drag the instruments and Download </span>
        <div class="control-group">
          <label>Selected: <span id="selected-element-name">None</span></label>
          <span id="scale-value"></span>
        </div>
        <div class="control-group">
          <button id="save-layout-btn" class="save-btn">Download Layout</button>
          <button id="reset-layout-btn" class="reset-btn">Reset to current</button>
        </div>
      </div>
    </div>

    <div class="instruments-grid">
      <object id="extra" type="image/svg+xml" data="instruments/extra.svg"></object>
      <object id="oxygen" type="image/svg+xml" data="instruments/oxygen.svg"></object>
      <object id="battery" type="image/svg+xml" data="instruments/battery.svg"></object>
      <object id="compass" type="image/svg+xml" data="instruments/compass.svg"></object>

      <object id="depth" type="image/svg+xml" data="instruments/depth.svg"></object>
      <object id="speed" type="image/svg+xml" data="instruments/speed.svg"></object>
      <object id="pitch" type="image/svg+xml" data="instruments/pitch.svg"></object>

      <object id="leftThrust" type="image/svg+xml" data="instruments/thrust-left.svg"></object>
      <object id="rightThrust" type="image/svg+xml" data="instruments/thrust-right.svg"></object>
      <object id="target" type="image/svg+xml" data="instruments/target.svg"></object>

      <object id="rudder" type="image/svg+xml" data="instruments/rudder.svg"></object>
      <object id="elevator" type="image/svg+xml" data="instruments/elevator.svg"></object>
      <object id="verticalThruster" type="image/svg+xml" data="instruments/thrust-vertical.svg"></object>

      <button id="restart-btn" onclick="restartGame()">Restart Mission</button>
      <svg id="fullscreen-icon" height="30px" width="30px" version="1.1" viewBox="10 10 18 18">
        <style>
          path {
            fill: white;
          }
        </style>
        <path d="m 10,16 2,0 0,-4 4,0 0,-2 L 10,10 l 0,6 0,0 z"></path>
        <path d="m 20,10 0,2 4,0 0,4 2,0 L 26,10 l -6,0 0,0 z"></path>
        <path d="m 24,24 -4,0 0,2 L 26,26 l 0,-6 -2,0 0,4 0,0 z"></path>
        <path d="M 12,20 10,20 10,26 l 6,0 0,-2 -4,0 0,-4 0,0 z"></path>
        <title>Click to go fullscreen</title>
      </svg>

      <div id="sub-data-text" style="display: none"></div>
    </div>

    <script src="js/instruments-window.js"></script>

    <!-- Layout Editor Script -->
    <script>
      (function () {
        "use strict";

        // State
        let editMode = false;
        let selectedElement = null;
        let isDragging = false;
        let isResizing = false;
        let dragStartPos = { x: 0, y: 0 };
        let resizeStartData = { scale: 1, distance: 0 };
        let elementStates = {}; // stores translateX, translateY, scale for each element

        // DOM Elements
        const panel = document.getElementById("layout-editor-panel");
        const scaleValue = document.getElementById("scale-value");
        const selectedName = document.getElementById("selected-element-name");
        const saveBtn = document.getElementById("save-layout-btn");
        const resetBtn = document.getElementById("reset-layout-btn");
        const instrumentsGrid = document.querySelector(".instruments-grid");

        // Parse transform to get translate and scale values
        function parseTransform(el) {
          const style = window.getComputedStyle(el);
          const transform = style.transform;
          let translateX = 0,
            translateY = 0,
            scale = 1;

          if (transform && transform !== "none") {
            // Matrix format: matrix(scaleX, skewY, skewX, scaleY, translateX, translateY)
            const matrix = transform.match(/matrix\(([^)]+)\)/);
            if (matrix) {
              const values = matrix[1].split(", ").map(parseFloat);
              scale = values[0]; // scaleX (assuming uniform scale)
              translateX = values[4];
              translateY = values[5];
            }
          }
          return { translateX, translateY, scale };
        }

        // Initialize element states from current CSS
        function initElementStates() {
          const gridRect = instrumentsGrid.getBoundingClientRect();
          const centerX = gridRect.width / 2;
          const centerY = gridRect.height / 2;

          document.querySelectorAll(".instruments-grid > object").forEach((el) => {
            const rect = el.getBoundingClientRect();
            const elCenterX = rect.left - gridRect.left + rect.width / 2;
            const elCenterY = rect.top - gridRect.top + rect.height / 2;

            // Calculate current offset from center
            const parsed = parseTransform(el);

            elementStates[el.id] = {
              translateX: parsed.translateX,
              translateY: parsed.translateY,
              scale: parsed.scale || 1,
            };
          });
        }

        // Toggle edit mode
        function toggleEditMode() {
          editMode = !editMode;
          document.body.classList.toggle("edit-mode", editMode);
          panel.classList.toggle("visible", editMode);

          if (editMode) {
            initElementStates();
            addDragOverlays();
          } else {
            removeDragOverlays();
            deselectElement();
          }
        }

        // Add transparent overlay divs for dragging (solves <object> event issue)
        function addDragOverlays() {
          document.querySelectorAll(".instruments-grid > object").forEach((el) => {
            const overlay = document.createElement("div");
            overlay.className = "drag-overlay";
            overlay.dataset.targetId = el.id;

            // Add resize handle to bottom-right corner
            const resizeHandle = document.createElement("div");
            resizeHandle.className = "resize-handle";
            resizeHandle.addEventListener("mousedown", startResize);
            overlay.appendChild(resizeHandle);

            // Position overlay exactly over the instrument
            updateOverlayPosition(overlay, el);

            overlay.addEventListener("mousedown", startDrag);
            overlay.addEventListener("click", selectElement);

            instrumentsGrid.appendChild(overlay);
          });
        }

        // Update overlay position to match element
        function updateOverlayPosition(overlay, el) {
          const rect = el.getBoundingClientRect();
          const gridRect = instrumentsGrid.getBoundingClientRect();
          overlay.style.left = rect.left - gridRect.left + "px";
          overlay.style.top = rect.top - gridRect.top + "px";
          overlay.style.width = rect.width + "px";
          overlay.style.height = rect.height + "px";
        }

        // Remove overlay divs
        function removeDragOverlays() {
          document.querySelectorAll(".drag-overlay").forEach((overlay) => {
            overlay.remove();
          });
        }

        // Select element
        function selectElement(e) {
          e.stopPropagation();
          if (!editMode) return;

          deselectElement();

          // Get the actual instrument element from overlay's data attribute
          const targetId = e.currentTarget.dataset.targetId;
          selectedElement = document.getElementById(targetId);

          if (!selectedElement) return;

          selectedElement.classList.add("selected");
          e.currentTarget.classList.add("selected");
          selectedName.textContent = selectedElement.id;

          // Update scale display
          const state = elementStates[selectedElement.id];
          if (state) {
            scaleValue.textContent = state.scale.toFixed(2) + "x";
          }
        }

        // Deselect element
        function deselectElement() {
          if (selectedElement) {
            selectedElement.classList.remove("selected");
            // Also remove selected class from overlay
            const overlay = document.querySelector(`.drag-overlay[data-target-id="${selectedElement.id}"]`);
            if (overlay) overlay.classList.remove("selected");
          }
          selectedElement = null;
          selectedName.textContent = "None";
          scaleValue.textContent = "";
        }

        // Start resizing from corner handle
        function startResize(e) {
          if (!editMode) return;
          e.preventDefault();
          e.stopPropagation(); // Don't trigger drag

          const overlay = e.target.parentElement;
          const targetId = overlay.dataset.targetId;
          const el = document.getElementById(targetId);
          if (!el) return;

          isResizing = true;

          // Clear any previous selection first
          if (selectedElement && selectedElement !== el) {
            selectedElement.classList.remove("selected");
            const prevOverlay = document.querySelector(`.drag-overlay[data-target-id="${selectedElement.id}"]`);
            if (prevOverlay) prevOverlay.classList.remove("selected");
          }

          // Select this element
          selectedElement = el;
          el.classList.add("selected");
          overlay.classList.add("selected");
          selectedName.textContent = el.id;

          const state = elementStates[el.id];
          scaleValue.textContent = state.scale.toFixed(2) + "x";

          // Calculate initial distance from element top-left to mouse
          const rect = el.getBoundingClientRect();
          const distance = Math.sqrt(Math.pow(e.clientX - rect.left, 2) + Math.pow(e.clientY - rect.top, 2));

          resizeStartData.scale = state.scale;
          resizeStartData.distance = distance;

          document.addEventListener("mousemove", resize);
          document.addEventListener("mouseup", stopResize);
        }

        // Resize - update scale based on distance from origin
        function resize(e) {
          if (!isResizing || !selectedElement) return;

          const rect = selectedElement.getBoundingClientRect();
          const currentDistance = Math.sqrt(Math.pow(e.clientX - rect.left, 2) + Math.pow(e.clientY - rect.top, 2));

          // Scale proportionally to distance change
          const scaleRatio = currentDistance / resizeStartData.distance;
          let newScale = resizeStartData.scale * scaleRatio;

          // Clamp scale between 0.1 and 3
          newScale = Math.max(0.1, Math.min(3, newScale));

          const state = elementStates[selectedElement.id];
          state.scale = newScale;

          // Apply transform
          selectedElement.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${newScale})`;

          // Update scale display
          scaleValue.textContent = newScale.toFixed(2) + "x";

          // Update overlay position
          const overlay = document.querySelector(`.drag-overlay[data-target-id="${selectedElement.id}"]`);
          if (overlay) {
            updateOverlayPosition(overlay, selectedElement);
          }
        }

        // Stop resizing
        function stopResize() {
          isResizing = false;
          document.removeEventListener("mousemove", resize);
          document.removeEventListener("mouseup", stopResize);
        }

        // Start dragging
        function startDrag(e) {
          // Don't drag if clicking resize handle
          if (!editMode || isResizing || e.target.classList.contains("resize-handle")) return;
          e.preventDefault();

          // Get the actual instrument element
          const targetId = e.currentTarget.dataset.targetId;
          const el = document.getElementById(targetId);
          if (!el) return;

          isDragging = true;

          // Select the element
          selectElement(e);

          // Store starting mouse position
          dragStartPos.x = e.clientX;
          dragStartPos.y = e.clientY;

          document.addEventListener("mousemove", drag);
          document.addEventListener("mouseup", stopDrag);
        }

        // Drag - update translate values relative to drag movement
        function drag(e) {
          if (!isDragging || !selectedElement) return;

          const state = elementStates[selectedElement.id];
          const deltaX = e.clientX - dragStartPos.x;
          const deltaY = e.clientY - dragStartPos.y;

          // Update translate values
          const newTranslateX = state.translateX + deltaX;
          const newTranslateY = state.translateY + deltaY;

          // Apply transform
          selectedElement.style.transform = `translate(${newTranslateX}px, ${newTranslateY}px) scale(${state.scale})`;

          // Update overlay position
          const overlay = document.querySelector(`.drag-overlay[data-target-id="${selectedElement.id}"]`);
          if (overlay) {
            updateOverlayPosition(overlay, selectedElement);
          }

          // Update stored state
          elementStates[selectedElement.id].translateX = newTranslateX;
          elementStates[selectedElement.id].translateY = newTranslateY;

          // Reset drag start for continuous movement
          dragStartPos.x = e.clientX;
          dragStartPos.y = e.clientY;
        }

        // Stop dragging
        function stopDrag() {
          isDragging = false;
          document.removeEventListener("mousemove", drag);
          document.removeEventListener("mouseup", stopDrag);
        }

        // Reset layout
        resetBtn.addEventListener("click", function () {
          if (confirm("Reset all positions to default? This cannot be undone.")) {
            location.reload();
          }
        });

        // Generate and download CSS with translate and scale only
        saveBtn.addEventListener("click", function () {
          let css = `/* ====================================
   Submarine Instruments Layout
   Each instrument uses translate() relative to center and scale() for sizing.
   ==================================== */

`;

          // Individual instrument positions using translate and scale
          document.querySelectorAll(".instruments-grid > object").forEach((el) => {
            const state = elementStates[el.id];
            if (!state) return;

            const tx = Math.round(state.translateX);
            const ty = Math.round(state.translateY);
            const sc = state.scale;

            css += `#${el.id} {\n`;
            css += `  transform: translate(${tx}px, ${ty}px) scale(${sc});\n`;
            css += `}\n\n`;
          });

          // Create and download file
          const blob = new Blob([css], { type: "text/css" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "instruments.css";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          alert("Layout downloaded as instruments.css. Move to the instruments/ folder and refresh the page.");
        });

        // Click outside to deselect
        document.addEventListener("click", function (e) {
          if (editMode && !e.target.closest(".drag-overlay") && !e.target.closest("#layout-editor-panel")) {
            deselectElement();
          }
        });

        // Keyboard shortcut: Ctrl/Cmd + Shift + E
        document.addEventListener("keydown", function (e) {
          if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "e") {
            e.preventDefault();
            toggleEditMode();
          }
        });
      })();

      // Fullscreen functionality
      // Wait for DOM to be ready before adding event listener
      document.addEventListener("DOMContentLoaded", function () {
        const fullscreenIcon = document.getElementById("fullscreen-icon");
        if (fullscreenIcon) {
          fullscreenIcon.addEventListener("click", function () {
            if (!document.fullscreenElement) {
              // Enter fullscreen
              document.documentElement.requestFullscreen().catch((err) => {
                console.error("Error attempting to enable fullscreen:", err);
              });
            } else {
              // Exit fullscreen
              document.exitFullscreen();
            }
          });
        }
      });
    </script>
  </body>

  <style>
    body {
      margin: 0;
      padding: 0px;
      font-family: "Arial", sans-serif;
      background-color: black;
    }

    /* Container for absolute positioning */
    .instruments-grid {
      position: relative;
      height: 100vh;
      width: 100vw;
      background-image: url("instruments/instruments-background.svg");
      background-size: 110% 100%;
      background-position: center center;
      padding: 0;
      margin: 0;
      overflow: hidden;
      background-color: black;
    }

    /* All SVG instruments */
    object[type="image/svg+xml"] {
      position: absolute;
      pointer-events: auto;
      cursor: pointer;
      top: 50%;
      left: 50%;
      transform-origin: top left;
      max-width: 500px;
    }

    #sub-data-text {
      color: #00ff00;
      font-size: 12px;
      padding: 2%;
      text-align: left;
      overflow-y: auto;
      white-space: pre;
      width: 96%;
      align-items: flex-start;
      justify-content: flex-start;
    }

    /* Restart button */
    #restart-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      background: #000;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.1em;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #restart-btn:hover {
      background: #ff8500;
    }

    /* Fullscreen icon */
    #fullscreen-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    #fullscreen-icon:hover {
      transform: scale(1.1);
    }

    /* ========================================
       LAYOUT EDITOR STYLES
       ======================================== */

    /* Editor Panel - Hidden by default */
    #layout-editor-panel {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      border-bottom: 3px solid #4299e1;
      padding: 0;
      z-index: 10000;
      transform: translateY(-100%);
      transition: transform 0.3s ease-in-out;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    #layout-editor-panel.visible {
      transform: translateY(0);
    }

    .editor-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      padding: 10px 15px;
      align-items: center;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 5px 10px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 5px;
    }

    .control-group label {
      font-size: 12px;
      color: #e2e8f0;
      white-space: nowrap;
    }

    .control-group button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .control-group button:hover {
      transform: scale(1.05);
    }

    .save-btn {
      background: #4299e1 !important;
      color: white !important;
      font-weight: bold;
    }

    .reset-btn {
      background: #ed8936 !important;
      color: white !important;
    }

    #scale-value {
      font-size: 12px;
      color: #68d391;
      min-width: 35px;
    }

    #selected-element-name {
      color: #68d391;
      font-weight: bold;
    }

    /* Drag overlay - transparent clickable layer over instruments in edit mode */
    .drag-overlay {
      position: absolute;
      cursor: move;
      z-index: 100;
      border: 2px dashed #4299e1;
      box-sizing: border-box;
      background: transparent;
    }

    .drag-overlay:hover {
      border-color: #68d391;
      background: rgba(66, 153, 225, 0.1);
    }

    .drag-overlay.selected {
      border: 3px solid #48bb78;
      box-shadow: 0 0 15px rgba(72, 187, 120, 0.5);
    }

    /* Resize handle in bottom-right corner */
    .resize-handle {
      position: absolute;
      bottom: -5px;
      right: -5px;
      width: 16px;
      height: 16px;
      background: #48bb78;
      border: 2px solid white;
      border-radius: 3px;
      cursor: nwse-resize;
      z-index: 101;
    }

    .resize-handle:hover {
      background: #68d391;
      transform: scale(1.2);
    }

    /* Push content down when editor is visible */
    body.edit-mode {
      padding-top: 60px;
    }

    body.edit-mode .instruments-grid {
      height: calc(100vh - 60px);
    }
  </style>
</html>
