<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Tangible Interfaces Submarine Navigation Game</title>
    <style>
      /* Welcome screen styles */
      .welcome-screen {
        margin: 0;
        padding: 0;
        font-family: "Arial", sans-serif;
        background: transparent;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: white;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10000;
      }

      .welcome-container {
        max-width: 800px;
        padding: 40px;
        text-align: center;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      h1 {
        font-size: 3em;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .subtitle {
        font-size: 1.2em;
        margin-bottom: 30px;
        opacity: 0.9;
      }

      .description {
        font-size: 1em;
        line-height: 1.6;
        margin-bottom: 30px;
        text-align: left;
      }

      .start-button {
        background: #ff6b35;
        color: white;
        border: none;
        padding: 10px 30px;
        font-size: 1.5em;
        border-radius: 30px;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
        transition: all 0.3s ease;
      }

      .description a {
        color: white;
      }

      .start-button:hover {
        background: #ff8500;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
      }

      .github-link {
        margin-top: 30px;
        font-size: 0.9em;
      }

      .github-link a {
        color: #00ffff;
        text-decoration: none;
      }

      .github-link a:hover {
        text-decoration: underline;
      }

      .instructions {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
      }

      .instructions h3 {
        margin-top: 0;
      }

      .instructions ul {
        text-align: left;
        line-height: 1.8;
      }

      /* Win overlay styles */
      #win-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10000;
        justify-content: center;
        align-items: center;
      }

      .win-container {
        max-width: 800px;
        padding: 40px;
        text-align: center;
        background: rgba(0, 50, 100, 0.95);
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        color: white;
      }

      .mission-complete {
        color: #00ff00;
        font-size: 3em;
        font-weight: bold;
        margin-bottom: 30px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .stats {
        font-size: 1.5em;
        margin: 30px 0;
        line-height: 2;
      }

      .stats div {
        margin: 10px 0;
      }

      .play-again-button {
        background: #ff6b35;
        color: white;
        border: none;
        padding: 20px 60px;
        font-size: 1.5em;
        border-radius: 50px;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
        transition: all 0.3s ease;
        margin-top: 20px;
      }

      .play-again-button:hover {
        background: #ff8500;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
      }

      /* Game Over overlay styles */
      #gameover-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.95);
        z-index: 10000;
        justify-content: center;
        align-items: center;
        animation: fadeToBlack 2s ease-in;
      }

      @keyframes fadeToBlack {
        from {
          background: rgba(0, 0, 0, 0);
        }
        to {
          background: rgba(0, 0, 0, 0.95);
        }
      }

      .gameover-container {
        max-width: 800px;
        padding: 40px;
        text-align: center;
        background: rgba(100, 0, 0, 0.8);
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        color: white;
      }

      .mission-failed {
        color: #ff4444;
        font-size: 3em;
        font-weight: bold;
        margin-bottom: 30px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      /* Game view styles */
      body {
        padding: 0;
        margin: 0;
        overflow: hidden;
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: gray;
      }

      #container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
      }

      #outside-scene {
        width: 100%;
        height: 100%;
        display: block;
      }

      kbd {
        display: inline-block; /* Allows padding and margin to be applied correctly */
        padding: 0.2em 0.6em; /* Adjust padding for key size */
        margin: 0.1em; /* Add slight spacing between keys */
        border: 1px solid #ccc; /* Basic border for key outline */
        border-radius: 3px; /* Rounded corners for a softer look */
        background-color: #f0f0f0; /* Light background color */
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px #fff inset; /* subtle shadow for depth */
        font-family: monospace; /* Monospace font for a classic key look */
        font-size: 0.85em; /* Adjust font size relative to parent */
        color: #333; /* Darker text color */
        text-align: center; /* Center the text within the key */
        line-height: 1; /* Ensure text is vertically centered */
        white-space: nowrap; /* Prevent text from wrapping inside the key */
      }
    </style>
  </head>
  <body>
    <!-- Welcome Screen (shown first) -->
    <div id="welcome-screen" class="welcome-screen">
      <div class="welcome-container">
        <h1>Tangible Interfaces Submarine Simulation</h1>

        <div class="description">
          <p>
            This game supports a
            <a href="https://turbek.com/Tangible-Interfaces/" target="_blank">Tangible Interfaces class</a> project. The students design integrated hardware
            controls, software, and UX design to control this submarine. More on this open source project on the
            <a
              href="https://github.com/steveturbek/Tangible-Interfaces-Submarine-Design-Project/tree/main?tab=readme-ov-file#tangible-interfaces-submarine-design-project"
              target="_blank"
              >Github Project Page</a
            >
          </p>

          <h3>How to Play:</h3>
          <ul>
            <li>Goal: Find and Navigate to the Gem and return to the surface opening</li>
            <li>Avoid coral obstacles and stay within boundaries</li>
            <li>Manage your oxygen and battery levels</li>
          </ul>

          <div style="display: flex; align-items: center; gap: 15px">
            <svg
              id="instruments-microBitGauge"
              fill="#cccccc"
              version="1.1"
              xmlns="http://www.w3.org/2000/svg"
              xmlns:xlink="http://www.w3.org/1999/xlink"
              viewBox="0 0 496 496"
              xml:space="preserve"
              style="width: 30px; cursor: pointer; flex-shrink: 0"
              title="Connect hardware controls to steer the submarine"
            >
              <path
                d="M92.688,0L48,44.688V80H0v112h48v128H0v64h48v112h448V0H92.688z M16,176V96h96v80H16z M16,368v-32h96v32H16z M480,480H64
              v-96h64v-24h16v-16h-16v-24H64V192h64v-16h16v-16h-16v-48h16V96h-16V80H64V51.312L99.312,16H480V480z"
              />
              <path
                d="M304,448h112v-16h16v-16h-16v-16h16v-16h-16v-16h16v-16h-16v-16h16v-16h-16v-16h16v-16h-16v-16h16v-16h-16v-16h16v-16
              h-16v-16h16v-16h-16v-16h16v-16h-16v-16h16v-16h-16v-16h16V96h-16V80h16V64h-16V48H304v16h-16v16h16v16h-16v16h16v16h-16v16h16
              v16h-16v16h16v16h-16v16h16v16h-16v16h16v16h-16v16h16v16h-16v16h16v16h-16v16h16v16h-16v16h16v16h-16v16h16V448z
              M320,64h80v368h-80V64z"
              />
              <circle cx="360" cy="88" r="8" />
              <path d="M256,64h-64v48h64V64z M240,96h-32V80h32V96z" />
              <path d="M256,144h-64v48h64V144z M240,176h-32v-16h32V176z" />
              <path
                d="M144,216v16h-16v-16h-16v16H96v48h16v16h16v-16h16v16h16v-16h16v16h16v-16h16v-48h-16v-16h-16v16h-16v-16H144z M192,248
              v16h-80v-16H192z"
              />
              <path
                d="M112,400c-17.648,0-32,14.352-32,32s14.352,32,32,32s32-14.352,32-32S129.648,400,112,400z M112,448
              c-8.824,0-16-7.176-16-16c0-8.824,7.176-16,16-16c8.816,0,16,7.176,16,16C128,440.824,120.816,448,112,448z"
              />
              <path
                d="M192,400c-17.648,0-32,14.352-32,32s14.352,32,32,32s32-14.352,32-32S209.648,400,192,400z M192,448
              c-8.824,0-16-7.176-16-16c0-8.824,7.176-16,16-16c8.816,0,16,7.176,16,16C208,440.824,200.816,448,192,448z"
              />
              <rect x="176" y="336" width="16" height="32" />
              <rect x="208" y="336" width="16" height="32" />
              <rect x="240" y="336" width="16" height="32" />
              <circle cx="96" cy="48" r="8" />
            </svg>
            <div id="microbit-status" style="text-align: left">
              Click circuit board to connect Micro:bit
              <p style="margin: 5px 0 0 0"><a href="https://makecode.microbit.org/device/usb/webusb/troubleshoot" target="new">Help with Microbit USB</a></p>
            </div>
          </div>
          <br />
          <details>
            <summary>This game is meant to be played with custom student-designed controllers, but these keyboard controls work for testing</summary>
            <kbd>a</kbd> Port (left) engine power increase<br />
            <kbd>z</kbd> Port (left) engine power decrease<br />
            <kbd>s</kbd> Starboard (right) engine power increase<br />
            <kbd>x</kbd> Starboard (right) engine power decrease<br />
            <kbd>‚Üê</kbd> Elevator Up<br />
            <kbd>‚Üí</kbd> Elevator Down<br />
            <kbd>‚Üë</kbd> Rudder Left<br />
            <kbd>‚Üì</kbd> Rudder Right<br />
            <kbd>d</kbd> Vertical Thrust Up<br />
            <kbd>c</kbd> Vertical Thrust Down<br />
            <kbd>ESC</kbd> Emergency Brake<br />
          </details>
        </div>

        <button class="start-button" onclick="startMission('easy')">Easy Mission</button>
        <button class="start-button" onclick="startMission('medium')">Medium Mission</button>
        <button class="start-button" onclick="startMission('hard')">Hard Mission</button>

        <div style="margin-top: 20px; color: #888; font-size: 0.8em">Press <strong>F</strong> for fullscreen</div>
      </div>
    </div>

    <!-- Win Overlay (shown when mission complete) -->
    <div id="win-overlay">
      <div class="win-container">
        <div class="mission-complete">üéâ MISSION COMPLETE! üéâ</div>
        <div class="stats">
          <div>‚è±Ô∏è Time: <span id="final-time">0:00</span></div>
          <div>ü´Å Oxygen Remaining: <span id="final-oxygen">0%</span></div>
          <div>üîã Battery Remaining: <span id="final-battery">0%</span></div>
        </div>
        <button class="play-again-button" onclick="restartGame()">Play Again</button>
      </div>
    </div>

    <!-- Game Over Overlay (shown when oxygen depleted) -->
    <div id="gameover-overlay">
      <div class="gameover-container">
        <div class="mission-failed">üíÄ OUT OF OXYGEN üíÄ</div>
        <div class="stats">
          <div style="font-size: 1.3em; margin: 20px 0">You ran out of oxygen!</div>
          <div>‚è±Ô∏è Survived: <span id="gameover-time">0:00</span></div>
        </div>
        <button class="play-again-button" onclick="restartGame()">Dive Again</button>
      </div>
    </div>

    <!-- Game Container (visible under welcome screen) -->
    <div id="container">
      <canvas id="outside-scene"></canvas>
    </div>

    <!-- Scripts loaded but not executed until game starts -->
    <script src="js/three.min.js"></script>
    <script src="js/simplex-noise.min.js"></script>

    <script src="js/gamepad-config.js"></script>
    <script src="js/gamepad-controller.js"></script>
    <script src="js/game.js"></script>
    <script src="js/controls.js"></script>
    <script src="js/sandTextureData.js"></script>
    <script src="js/rendering.js"></script>
    <script src="js/microbit-serial.js"></script>
    <!-- <script src="js/instruments.js"></script> -->

    <script>
      // Make instrumentsWindow globally accessible so game.js can access it
      window.instrumentsWindow = null;
      let gameStarted = false;

      // Close instruments window when main page reloads or closes
      window.addEventListener("beforeunload", function () {
        if (window.instrumentsWindow && !window.instrumentsWindow.closed) {
          window.instrumentsWindow.close();
        }
      });

      // Initialize renderer on page load to show scene under welcome screen
      window.addEventListener("load", function () {
        // console.log("Page loaded, initializing renderer...");

        const canvas = document.getElementById("outside-scene");
        const container = document.getElementById("container");
        // console.log("Container dimensions:", container.clientWidth, "x", container.clientHeight);
        // console.log("Canvas dimensions:", canvas.width, "x", canvas.height);

        if (typeof initRenderer === "function") {
          try {
            initRenderer();
            // console.log("Renderer initialized successfully");
            // console.log("Canvas dimensions after init:", canvas.width, "x", canvas.height);

            // Start a simple animation loop to render the scene
            function previewLoop() {
              if (!gameStarted && typeof renderUnderwaterScene === "function") {
                try {
                  renderUnderwaterScene();
                  requestAnimationFrame(previewLoop);
                } catch (error) {
                  console.error("Error in preview loop:", error);
                }
              }
            }
            previewLoop();
            // console.log("Preview loop started");
          } catch (error) {
            console.error("Error initializing renderer:", error);
          }
        } else {
          console.error("initRenderer function not found");
        }

        // Set up microbit connection button click handler
        const microbitGauge = document.getElementById("instruments-microBitGauge");
        if (microbitGauge && typeof connectToMicrobit === "function") {
          // console.log("Setting up click handler on inline circuit board SVG");
          microbitGauge.addEventListener("click", connectToMicrobit);
        } else {
          console.error("Circuit board element or connectToMicrobit function not found");
        }

        // Try to auto-connect to previously paired Micro:bit
        if ("serial" in navigator && typeof autoConnectToMicrobit === "function") {
          setTimeout(() => {
            autoConnectToMicrobit();
          }, 1000);
        }
      });

      function startMission(difficulty = "hard") {
        if (gameStarted) return;

        // Store difficulty level globally for game.js and rendering.js to access
        window.gameDifficulty = difficulty;

        gameStarted = true;

        // Open or reuse instruments window
        // Using the named window approach - if a window with this name already exists,
        // it will be reused and brought to focus
        window.instrumentsWindow = window.open(
          "instruments.html",
          "Submarine Instruments",
          "width=1280,height=720,resizable=yes,scrollbars=no,toolbar=no,menubar=no,location=no,status=no"
        );

        if (!window.instrumentsWindow) {
          alert("Please allow popups to view the instruments panel. Check your browser settings and try again.");
          gameStarted = false;
          return;
        }

        // Hide welcome screen
        document.getElementById("welcome-screen").style.display = "none";

        // Start the game after a short delay to ensure instruments window is ready
        // This works whether it's a new window or reusing an existing one
        setTimeout(() => {
          // Refocus the main window so keyboard events work here
          window.focus();

          // Start the game loop from game.js (renderer already initialized)
          if (typeof startGame === "function") {
            startGame();
          }
        }, 500);
      }

      // Listen for messages from instruments window (via postMessage API)
      // This allows communication between windows using file:// protocol
      window.addEventListener("message", function (event) {
        // Accept messages from any origin (needed for file:// protocol)
        if (!event.data) return;

        // Handle keyboard events forwarded from instruments window
        if (event.data.type === "keydown" || event.data.type === "keyup") {
          // Create and dispatch a keyboard event on the document
          try {
            const keyEvent = new KeyboardEvent(event.data.type, {
              key: event.data.key,
              code: event.data.code,
              keyCode: event.data.keyCode,
              which: event.data.which,
              shiftKey: event.data.shiftKey,
              ctrlKey: event.data.ctrlKey,
              altKey: event.data.altKey,
              metaKey: event.data.metaKey,
              repeat: event.data.repeat,
              bubbles: true,
              cancelable: true,
            });

            // Dispatch the event
            document.dispatchEvent(keyEvent);

            // If the event didn't trigger (synthetic events sometimes don't work),
            // manually trigger the handler if it exists
            if (typeof handleKeyPress === "function" && event.data.type === "keydown") {
              handleKeyPress(keyEvent);
            }
          } catch (error) {
            console.error("Error creating keyboard event:", error);
          }
        }

        // Handle restart game request from instruments window
        if (event.data.type === "restartGame") {
          restartGame();
        }

        // Handle microbit connection requests
        if (event.data.type === "microbitConnect") {
          if (typeof connectToMicrobit === "function") {
            connectToMicrobit();
          }
        }

        if (event.data.type === "microbitDisconnect") {
          if (typeof disconnectFromMicrobit === "function") {
            disconnectFromMicrobit();
          }
        }

        if (event.data.type === "microbitAutoConnect") {
          if (typeof autoConnectToMicrobit === "function") {
            autoConnectToMicrobit();
          }
        }
      });

      // Fullscreen functionality for main window - keyboard shortcut 'F'
      document.addEventListener("keydown", function (e) {
        if (e.key === "f" || e.key === "F") {
          e.preventDefault();
          if (!document.fullscreenElement) {
            // Enter fullscreen
            document.documentElement.requestFullscreen().catch((err) => {
              console.error("Error attempting to enable fullscreen:", err);
            });
          } else {
            // Exit fullscreen
            document.exitFullscreen();
          }
        }
      });

      // Handle fullscreen change to resize canvas properly
      document.addEventListener("fullscreenchange", function () {
        setTimeout(() => {
          const canvas = document.getElementById("outside-scene");
          const container = document.getElementById("container");

          // Get actual screen dimensions
          const width = window.innerWidth;
          const height = window.innerHeight;

          // Force container to fill the actual screen
          container.style.width = width + "px";
          container.style.height = height + "px";

          // Force canvas to match
          canvas.style.width = width + "px";
          canvas.style.height = height + "px";

          // Update renderer and camera directly
          if (typeof renderer !== "undefined" && renderer) {
            renderer.setSize(width, height, false);
            if (typeof camera !== "undefined" && camera) {
              camera.aspect = width / height;
              camera.updateProjectionMatrix();
            }
          }

          // Also trigger standard resize handler
          window.dispatchEvent(new Event("resize"));
        }, 100);
      });
    </script>
  </body>
</html>
